#+TITLE:  Patrons et bibliothèque standard
#+AUTHOR: Xavier Garrido
#+DATE:   01/10/2013
#+OPTIONS: toc:nil ^:{}
#+STARTUP:     beamer
#+LATEX_CLASS: cpp-slide

* Notion de patron (=template=)

Un *patron* (=template=) permet de définir d'un seul coup un ensemble de
fonctions ou de classes qui partagent une implémentation commune.


* Illustration d'un patron de fonction

#+BEGIN_SRC c++
  int min(const int a, const int b)
  {
    if(a < b) return a;
    else return b;
  }
  float min(const float a, const float b)
  {
    if(a < b) return a;
    else return b;
  }
  unsigned int min(const unsigned int a, const unsigned int b)
  {
    if(a < b) return a;
    else return b;
  }
#+END_SRC

Ces trois fonctions s'écrivent de la même manière.

* Illustration d'un patron de fonction

#+BEGIN_SRC c++
  template<typename T>
  T min(const T a, const T b)
  {
    if(a < b) return a;
    else return b;
  }
#+END_SRC

- Lors de la compilation, suivant le type des arguments fournis, le compilateur
  implémente automatiquement la variante requise.

- Il est possible de forcer l'utilisation d'une variante en spécifiant par
  exemple =min<float>=.

* Illustration d'un patron de fonction

#+BEGIN_SRC c++
  int main()
  {
    int i1 = 2, i2 = 7;
    float f1 = 3.4, f2 = 5.6;
    char c1 = 'd', c2 = 'z';

    cout << "min(i1,i2) = " << min(i1,i2) << endl;
    cout << "min(f1,f2) = " << min(f1,f2) << endl;
    cout << "min(c1,c2) = " << min(c1,c2) << endl;
  }
#+END_SRC

* Patron de classe

Il est également possible de définir des patrons de classe :

#+BEGIN_SRC c++
  template<class T>
  class Point
  {
  public:
    Point(const T abs = 0, const T ord = 0)
      : m_X(abs), m_Y(ord) {}
  private:
    T m_X;
    T m_Y;
  };
#+END_SRC

* Patron de classe

#+BEGIN_SRC c++
  int main()
  {
    Point<double> point1(5.0, 3.0);
    Point<int> point2(7, 9);
  }
#+END_SRC

- Il faut donner explicitement le type voulu.

- Attention, les classes =Point<double>= et =Point<int>= sont distinctes et
  n'ont aucune parenté : on ne peut pas écrire =point1 = point2;=.


* La bibliothèque standard STL

La bibliothèque standard STL (/Standard Template Library/) du \Cpp fournit *un
ensemble de conteneurs* exploitant très largement les mécanismes du \Cpp

- l'approche objet et les capacités d'abstraction en particulier sur les
  opérateurs,

- la surdéfinition des opérateurs,

- les patrons ou templates.

La STL fournit par ailleurs des algorithmes (optimisés) permettant la
manipulation aisée de ces nouveaux containers (initialisation, recherche de
valeurs...)

#+BEGIN_CENTER
http://cplusplus.com/

http://www.sgi.com/tech/stl/table_of_contents.html
#+END_CENTER

* La classe =string=

En C, une chaîne de caractère se présente sous la forme d'un tableau
de caractères

#+BEGIN_SRC c++
  char * name = new char[256];
#+END_SRC

La manipulation de ces pointeurs de caractères peut se faire par le biais de
fonctions définies dans =string.h= (=cstring= en \Cpp)

#+BEAMER: \vspace{0.5cm}
Le C n'utilisant pas la surcharge d'opérateurs tels que =+= ou ====, la
manipulation est globalement complexe (sans parler de la désallocation de
mémoire).

* La classe =string=

#+BEGIN_SRC c++
  #include <string>
  int main()
  {
    // Initialisation
    std::string string1 = "abcd";
    std::string string2 = string1;

    // Concaténation
    string1 += "efgh";
    std::cout << string1 + string2 << std::endl;

    // Comparaison
    if(string1 == "abcdefgh") {
      std::cout << "test réussi" << std::endl;
    }

    // Longueur
    std::cout << "La chaîne " << string1 << " comporte "
              << string1.size() << " caractères" << std::endl;
  }
#+END_SRC


* La classe =vector=
:PROPERTIES:
:REVEAL_BACKGROUND: #123456
:END:

- La classe =vector= est proche par son utilisation du tableau défini en C,

- L'avantage majeur de la classe =vector= tient en trois points :

  1. l'utilisation de la notion de patron lui permet de manipuler n'importe quel
     type de données,

  2. sa capacité à réallouer automatiquement l'espace mémoire nécessaire via la
     méthode =push_back=,

  3. la désallocation de mémoire est automatique grâce à l'implémentation d'un
     destructeur.

* La classe =vector=

#+BEGIN_SRC c++
  #include <vector>
  #include <iostream>

  int main()
  {
    // Déclaration d'un vecteur d'entiers de taille non connue
    std::vector<int> my_vector1;

    // Ajout de trois elements
    my_vector1.push_back (4);
    my_vector1.push_back (2);
    my_vector1.push_back (5);

    // La méthode size précise le nombre d'entrée courante
    for (size_t i = 0; i < my_vector1.size (); ++i)
      std::cout << i << " " << my_vector1[i] << std::endl;
  }
#+END_SRC

* La classe =vector=

#+BEGIN_SRC c++
  // Création d'un vecteur d'entier contenant 70,70,70,70,70
  std::vector<int> my_vector2 (5, 70);

  // Réassignation des valeurs de ce vecteur
  my_vector2[0] = 5;
  my_vector2[1] = 3;
  my_vector2[2] = 7;
  my_vector2[3] = 4;
  my_vector2[4] = 8;

  // Nettoyage de l'espace mémoire
  my_vector2.clear ();
#+END_SRC

* La classe =vector=

#+BEGIN_SRC c++
  // Création d'un vecteur de particule
  std::vector<particule> my_particles;

  // Création d'un ensemble de particule
  for (size_t i = 0; i < 10; ++i)
    {
      particule my_particle (0.511*i, -1.6e-19*i);
      my_particles.push_back (my_particle);

      // Affiche la dernière particule
      my_particles.back ().affiche ();
    }
#+END_SRC
